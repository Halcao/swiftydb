{"name":"SwiftyDB","tagline":"Making SQLite databases a blast","body":"![alt text] (http://i.imgur.com/uQhXJLJ.png?1 \"Logo\")\r\n\r\nThere are many libraries out there that aims to help developers easily create and use SQLite databases. \r\nUnfortunately developers still have to get bogged down in simple tasks such as writing table definitions \r\nand SQL queries. SwiftyDB automatically handles everything you don't want to spend your time doing.\r\n\r\n[![CI Status](https://img.shields.io/travis/Oyvindkg/swiftydb/master.svg?style=flat)](https://travis-ci.org/Oyvindkg/swiftydb)\r\n[![Version](https://img.shields.io/cocoapods/v/SwiftyDB.svg?style=flat)](http://cocoapods.org/pods/SwiftyDB)\r\n[![License](https://img.shields.io/cocoapods/l/SwiftyDB.svg?style=flat)](http://cocoapods.org/pods/SwiftyDB)\r\n[![Platform](https://img.shields.io/cocoapods/p/SwiftyDB.svg?style=flat)](http://cocoapods.org/pods/SwiftyDB)\r\n\r\nYou can find the [documentation here](http://oyvindkg.github.io/swiftydb/docs/)\r\n\r\n**Content**<br />\r\n[Features](#features)<br />\r\n[Usage](#usage)<br />\r\n&emsp; [Access the database](#accessTheDatabase)<br />\r\n&emsp;&emsp; [Synchronous access](#syncAccess)<br />\r\n&emsp;&emsp;&emsp; [Add or update data](#syncAddOrUpdate)<br />\r\n&emsp;&emsp;&emsp; [Retrieve data](#syncRetrieveData)<br />\r\n&emsp;&emsp;&emsp; [Retrieve objects](#syncRetrieveObjects)<br />\r\n&emsp;&emsp;&emsp; [Delete data](#syncDelete)<br />\r\n&emsp;&emsp; [Aynchronous access](#asyncAccess)<br />\r\n&emsp;&emsp;&emsp; [Add or update data](#asyncAddOrUpdate)<br />\r\n&emsp;&emsp;&emsp; [Retrieve data](#asyncRetrieveData)<br />\r\n&emsp;&emsp;&emsp; [Retrieve objects](#asyncRetrieveObjects)<br />\r\n&emsp;&emsp;&emsp; [Delete data](#asyncDelete)<br />\r\n&emsp; [Result format](#resultFormat)<br />\r\n&emsp;&emsp;[Handling results](#handlingResults)<br />\r\n&emsp;&emsp;&emsp;[Handling values](#handlingValues)<br />\r\n&emsp;&emsp;&emsp;[Handling errors](#handlingErrors)<br />\r\n&emsp; [Filter results](#filterResults)<br />\r\n&emsp;&emsp;[Simple filters](#simpleFilters)<br />\r\n&emsp;&emsp;[Complex filters](#complexFilters)<br />\r\n&emsp; [Defining your classes](#definingYourClasses)<br />\r\n&emsp;&emsp; [Primary keys](#primaryKeys)<br />\r\n&emsp;&emsp; [Ignoring properties](#ignoringProperties)<br />\r\n&emsp; [How to retrieve objects](#howToRetrieveObjects)<br />\r\n[Installation](#installation)<br />\r\n[License](#license)\r\n\r\n### <a name=\"features\">Features</a>\r\n- [x] Creates and updates databases, tables, and records automatically\r\n- [x] Store any native Swift type\r\n- [x] Supports optional types\r\n- [x] Simple equality-based filtering\r\n- [x] Thread safe database operations\r\n- [x] Supports asynchronous database access\r\n- [x] 100% documented\r\n- [x] Complex filtering\r\n- [ ] Store nested objects\r\n- [ ] Store collections\r\n\r\n## <a name=\"usage\">Usage</a>\r\n\r\nAlmost pure plug and play. All you have to do is create an instance of SwiftyDB, and everything will be handled automagically behind the scenes ðŸŽ©\r\n\r\n### <a name=\"accessTheDatabase\">Access the database</a>\r\nTell SwiftyDB what you want to call your database, and you are ready to go. If a database with the provided name does not exist, it will be created.\r\n\r\n```Swift\r\nlet database = SwiftyDB(databaseName: \"dogtopia\")\r\n```\r\n\r\n#### <a name=\"syncAccess\">Synchronous access</a>\r\n\r\n##### <a name=\"syncAddOrUpdate\">Add or update a record</a>\r\n```Swift\r\ndatabase.addObject(dog, update: true)\r\ndatabase.addObjects(dogs, update: true)\r\n````\r\n\r\n##### <a name=\"syncRetrieveData\">Retrieve data</a>\r\n\r\nRetrieve data with datatypes matching those of the type's properties\r\n```Swift\r\n/* Array of dictionaries representing `Dog` objects from the database */\r\ndatabase.dataForType(Dog.self)\r\ndatabase.dataForType(Dog.self, matchingFilters: [\"id\": 1])\r\n````\r\nDog data example\r\n```Swift\r\n[\r\n    \"id\": 1,                // As an Int\r\n    \"name\": \"Ghost\",        // As a String\r\n    \"owner\": \"John Snow\",   // As a String\r\n    \"birth\": August 6, 1996 // As an NSDate\r\n]\r\n```\r\n\r\n##### <a name=\"syncRetrieveObjects\">Retrieve objects</a>\r\n\r\nRetrieve objects with data from the database\r\n```Swift\r\ndatabase.objectsForType(Dog.self)\r\ndatabase.objectsForType(Dog.self, matchingFilters: [\"id\": 1])\r\n````\r\n\r\n> In order to retrieve objects, Swift currently imposes some [restictions on your classes](#howToRetrieveObjects)\r\n\r\n##### <a name=\"syncDelete\">Delete records</a>\r\n```Swift\r\ndatabase.deleteObjectsForType(Dog.self)\r\ndatabase.deleteObjectsForType(Dog.self, matchingFilters: [\"name\": \"Max\"])\r\n```\r\n\r\n#### <a name=\"asyncAccess\">Asynchronous access</a>\r\n\r\n##### <a name=\"asyncAddOrUpdate\">Add or update a record</a>\r\n```Swift\r\ndatabase.asyncAddObject(dog) { (result) -> Void in\r\n    if let error = result.error {\r\n        // Handle error\r\n    }\r\n}\r\n````\r\n\r\n##### <a name=\"asyncRetrieveData\">Retrieve data</a>\r\n\r\nRetrieve data with datatypes matching those of the type's properties\r\n```Swift\r\ndatabase.asyncDataForType(Dog.self) { (result) -> Void in\r\n    if let data = result.value {\r\n        // Process data\r\n    }\r\n}\r\n````\r\n\r\n##### <a name=\"asyncRetrieveObjects\">Retrieve objects</a>\r\n\r\nRetrieve data with datatypes matching those of the type's properties\r\n```Swift\r\ndatabase.asyncObjectsForType(Dog.self) { (result) -> Void in\r\n    if let objects = result.value {\r\n        // Handle objects\r\n    }\r\n}\r\n````\r\n\r\n> In order to retrieve objects, Swift currently imposes some [restictions on your classes](#howToRetrieveObjects)\r\n\r\n##### <a name=\"asyncDelete\">Delete records</a>\r\n```Swift\r\ndatabase.asyncDeleteObjectsForType(Dog.self) { (result) -> Void in\r\n    if let error = result.error {\r\n        // Handle error\r\n    }\r\n}\r\n```\r\n\r\n### <a name=\"filterResults\">Filter results</a>\r\n\r\n`Filter` objects are used to filter queries. All filters are translated to SQLite before querying the database.\r\n\r\n#### <a name=\"simpleFilters\">Simple filters</a>\r\nThe easiest way to define your filter, is by using a dictionary:\r\n```Swift\r\ndatabase.objectsForType(Dog.self, matchingFilters: [\"name\": \"Ghost\"])\r\n```\r\nAll objects with the name 'Ghost' will be retrieved\r\n\r\n#### <a name=\"complexFilters\">Complex filters</a>\r\n\r\nFor more complex filters, you can instantiate a new `Filter` object, and define your filters\r\n\r\n```Swift\r\nlet filter = Filter.equal(\"name\", value: \"Ghost\")\r\nfilter.like(\"owner\", pattern: \"J_h%\")\r\nfilter.greaterThan(\"id\", value: 3)\r\n\r\ndatabase.objectsForType(Dog.self, matchingFilters: filter)\r\n```\r\n\r\nYou can also chain your filters\r\n\r\n```Swift\r\nlet filter = Filter.equal(\"name\", value: \"Ghost\")\r\n                   .like(\"owner\", pattern: \"J_h%\")\r\n                   .greaterThan(\"id\", value: 3)\r\n\r\ndatabase.objectsForType(Dog.self, matchingFilters: filter)\r\n```\r\n\r\nSee all available filters in the [documentation](http://oyvindkg.github.io/swiftydb/docs/Classes/Filter.html).\r\n\r\n### <a name=\"resultFormat\">Result format</a>\r\nAll queries returns the result as a `Result`. It will either be a `.Success` wrapping data from the query, or an `.Error` wrapping the thrown error.\r\n\r\n```Swift\r\nenum Result<A: Any>: BooleanType {\r\n    case Success(A)\r\n    case Error(ErrorType)\r\n    \r\n    var data: A?\r\n    var error: ErrorType?\r\n    var isSuccess: Bool\r\n    var boolValue: Bool {return isSuccess}\r\n}\r\n```\r\n\r\n#### <a name=\"handlingResults\">Handling results</a>\r\nThe implementation of `Result` makes it a versatile tool that can (hopefully ðŸ˜¬) be adapted to your programming style\r\n\r\n##### <a name=\"handlingValues\">Handling values</a>\r\nYou can capture the data from a query with the `value` property. If an error was thrown, this property will be `nil`.\r\n\r\n```Swift\r\nif let object = result.value {\r\n    // Process objects\r\n}\r\n```\r\n\r\n##### <a name=\"handlingErrors\">Handling errors</a>\r\nYou can detect an error like this\r\n```Swift\r\nif !database.addObject(dog) {\r\n    // An error occured\r\n}\r\n```\r\nor capture it using the `error` property like this\r\n\r\n```Swift\r\nif let error = result.error {\r\n    // Process objects\r\n}\r\n```\r\nIf you want to, you can even bring your sledgehammer and start cracking some nuts\r\n```Swift\r\nswitch result {\r\n    case .Success(let value):\r\n        // Process value\r\n    case .Error(let error):\r\n        // Handle error\r\n}\r\n```\r\n\r\n### <a name=\"definingYourClasses\">Defining your classes</a>\r\nLet's use this simple `Dog` class as an example\r\n\r\n```Swift\r\nclass Dog {\r\n    var id: Int?\r\n    var name: String?\r\n    var owner: String?\r\n    var birth: NSDate?\r\n}\r\n```\r\n\r\nAll objects must conform to the `Storable` protocol.\r\n\r\n```Swift\r\npublic protocol Storable {\r\n    init()\r\n}\r\n```\r\n\r\nBy adding the `Storable` protocol and implementing `init()`, you are already ready to go.\r\n\r\n```Swift\r\nclass Dog: Storable {\r\n    var id: Int?\r\n    var name: String?\r\n    var owner: String?\r\n    var birth: NSDate?\r\n    \r\n    required init() {}\r\n}\r\n```\r\n\r\n> SwiftyDB supports inheritance. Valid properties from both the class and the superclass will be stored automatically\r\n\r\n##### <a name=\"primaryKeys\">Primary keys</a>\r\nIt is recommended to implement the `PrimaryKeys` protocol. The `primaryKeys()` method should return a set of property names which uniquely identifies an object.\r\n\r\n```Swift\r\nextension Dog: PrimaryKeys {\r\n    class func primaryKeys() -> Set<String> {\r\n        return [\"id\"]\r\n    }\r\n}\r\n```\r\n\r\n##### <a name=\"ignoringProperties\">Ignoring properties</a>\r\nIf your class contains properties that you don't want in your database, you can implement the `IgnoredProperties` protocol.\r\n\r\n```Swift\r\nextension Dog: IgnoredProperties {\r\n    class func ignoredProperties() -> Set<String> {\r\n        return [\"name\"]\r\n    }\r\n}\r\n```\r\n> Properties with datatypes that are not part of the `SQLiteValue` protocol, as defined by [TinySQLite](https://github.com/Oyvindkg/tinysqlite/blob/master/Pod/Classes/DatabaseConnection.swift), will automatically be ignored by SwiftyDB\r\n\r\n### <a name=\"howToRetrieveObjects\">How to retrieve objects</a>\r\n\r\nSwiftyDB can also retrieve complete objects with all properties assigned with data from the database. In order to achieve this, the type must be a subclass of `NSObject`, and all property types must be representable in in Objective-C. This is because pure Swift currently does not support dynamic assignment of properties. \r\n\r\n**Dynamic property types**\r\n- [x] `Int`\r\n- [x] `UInt`\r\n- [x] `Float`\r\n- [x] `Double`\r\n- [x] `Bool`\r\n- [x] `String` / `String?`\r\n- [x] `NSNumber` / `NSNumber?`\r\n- [x] `NSString` / `NSString?`\r\n- [x] `NSDate` / `NSDate?`\r\n- [x] `NSData` / `NSData?`\r\n\r\n\r\nAn updated Dog class that can be used to retrieve complete objects from the database:\r\n\r\n```Swift\r\nclass Dog: NSObject, Storable {\r\n    var id: NSNumber? // Notice that 'Int?' is not supported. Use NSNumber? instead\r\n    var name: String?\r\n    var owner: String?\r\n    var birth: NSDate?\r\n    \r\n    override required init() {\r\n        super.init()\r\n    }\r\n}\r\n```\r\n\r\n## <a name=\"installation\">Installation</a>\r\n\r\nSwiftyDB is available through [CocoaPods](http://cocoapods.org). To install\r\nit, simply add the following line to your Podfile:\r\n\r\n```ruby\r\npod \"SwiftyDB\"\r\n```\r\n\r\n## Author\r\n\r\nÃ˜yvind Grimnes, oyvindkg@yahoo.com\r\n\r\n## <a name=\"License\">License</a>\r\n\r\nSwiftyDB is available under the MIT license. See the LICENSE file for more info.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}